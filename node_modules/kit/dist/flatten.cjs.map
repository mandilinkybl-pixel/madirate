{"version":3,"sources":["../src/runtime/flatten.ts"],"names":[],"mappings":";;;;;AAEO,SAAS,OAAA,CAAQ,KAAA,EAAgB,YAAA,GAAe,KAAA,EAAgB;AACrE,EAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,KAAK,CAAA,EAAG;AAExB,IAAA,OAAO,KAAA,CAAM,MAAA,CAAkB,CAAC,GAAA,EAAK,GAAA,KAAQ;AAC3C,MAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,GAAG,CAAA,EAAG;AACtB,QAAA,GAAA,CAAI,IAAA,CAAK,GAAI,OAAA,CAAQ,GAAA,EAAK,YAAY,CAAe,CAAA;AAAA,MACvD,CAAA,MAAA,IAAW,OAAO,GAAA,KAAQ,QAAA,IAAY,QAAQ,IAAA,EAAM;AAClD,QAAA,GAAA,CAAI,IAAA,CAAK,OAAA,CAAQ,GAAA,EAAK,YAAY,CAAC,CAAA;AAAA,MACrC,CAAA,MAAO;AACL,QAAA,GAAA,CAAI,KAAK,GAAG,CAAA;AAAA,MACd;AACA,MAAA,OAAO,GAAA;AAAA,IACT,CAAA,EAAG,EAAE,CAAA;AAAA,EACP,CAAA,MAAA,IAAW,OAAO,KAAA,KAAU,QAAA,IAAY,UAAU,IAAA,EAAM;AAEtD,IAAA,MAAM,SAAoC,EAAC;AAE3C,IAAA,MAAM,OAAA,GAAU,CAAC,GAAA,EAA8B,SAAA,GAAY,EAAA,KAAO;AAChE,MAAA,KAAA,MAAW,CAAC,GAAA,EAAK,GAAG,KAAK,MAAA,CAAO,OAAA,CAAQ,GAAG,CAAA,EAAG;AAC5C,QAAA,MAAM,SAAS,SAAA,GAAY,CAAA,EAAG,SAAS,CAAA,CAAA,EAAI,GAAG,CAAA,CAAA,GAAK,GAAA;AACnD,QAAA,IAAI,KAAA,CAAM,OAAA,CAAQ,GAAG,CAAA,EAAG;AACtB,UAAA,IAAI,YAAA,EAAc;AAEhB,YAAA,MAAM,cAAA,GAAiB,OAAA,CAAQ,GAAA,EAAK,YAAY,CAAA;AAChD,YAAA,cAAA,CAAe,OAAA,CAAQ,CAAC,IAAA,EAAM,KAAA,KAAU;AACtC,cAAA,MAAA,CAAO,CAAA,EAAG,MAAM,CAAA,CAAA,EAAI,KAAK,EAAE,CAAA,GAAI,IAAA;AAAA,YACjC,CAAC,CAAA;AAAA,UACH,CAAA,MAAO;AAEL,YAAA,MAAA,CAAO,MAAM,CAAA,GAAI,OAAA,CAAQ,GAAA,EAAK,YAAY,CAAA;AAAA,UAC5C;AAAA,QACF,CAAA,MAAA,IAAW,OAAO,GAAA,KAAQ,QAAA,IAAY,QAAQ,IAAA,EAAM;AAClD,UAAA,OAAA,CAAQ,KAAgC,MAAM,CAAA;AAAA,QAChD,CAAA,MAAO;AACL,UAAA,MAAA,CAAO,MAAM,CAAA,GAAI,GAAA;AAAA,QACnB;AAAA,MACF;AAAA,IACF,CAAA;AAEA,IAAA,OAAA,CAAQ,KAAgC,CAAA;AACxC,IAAA,OAAO,MAAA;AAAA,EACT;AAGA,EAAA,OAAO,KAAA;AACT;AAEA,IAAO,eAAA,GAAQ","file":"flatten.cjs","sourcesContent":["import { Primitive } from '../types/primitive.type';\n\nexport function flatten(input: unknown, unpackArrays = false): unknown {\n  if (Array.isArray(input)) {\n    // recursively flatten array\n    return input.reduce<unknown[]>((acc, val) => {\n      if (Array.isArray(val)) {\n        acc.push(...(flatten(val, unpackArrays) as unknown[]));\n      } else if (typeof val === 'object' && val !== null) {\n        acc.push(flatten(val, unpackArrays)); // nested objects remain objects\n      } else {\n        acc.push(val);\n      }\n      return acc;\n    }, []);\n  } else if (typeof input === 'object' && input !== null) {\n    // object â†’ flat object\n    const result: Record<string, Primitive> = {};\n\n    const recurse = (obj: Record<string, unknown>, parentKey = '') => {\n      for (const [key, val] of Object.entries(obj)) {\n        const newKey = parentKey ? `${parentKey}.${key}` : key;\n        if (Array.isArray(val)) {\n          if (unpackArrays) {\n            // unpack array into separate properties\n            const flattenedArray = flatten(val, unpackArrays) as unknown[];\n            flattenedArray.forEach((item, index) => {\n              result[`${newKey}.${index}`] = item as Primitive;\n            });\n          } else {\n            // keep array as is\n            result[newKey] = flatten(val, unpackArrays) as unknown as Primitive;\n          }\n        } else if (typeof val === 'object' && val !== null) {\n          recurse(val as Record<string, unknown>, newKey);\n        } else {\n          result[newKey] = val as Primitive;\n        }\n      }\n    };\n\n    recurse(input as Record<string, unknown>);\n    return result;\n  }\n\n  // if primitive\n  return input;\n}\n\nexport default flatten;\n"]}